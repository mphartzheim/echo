// release.js
import { execSync } from 'child_process';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import readline from 'readline';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const rootDir = path.join(__dirname, '..');
const packageJsonPath = path.join(rootDir, 'package.json');
const distDir = path.join(rootDir, 'dist');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

// Helper function to prompt for input
const prompt = (question) => new Promise((resolve) => rl.question(question, resolve));

// Helper function to run a command and return stdout
const run = (cmd, options = {}) => {
    console.log(`> ${cmd}`);
    return execSync(cmd, { encoding: 'utf8', stdio: 'inherit', ...options });
};

// Function to extract the latest version's changes from CHANGELOG.md
async function createReleaseNotes(version) {
    console.log('\nCreating release notes for the current version...');

    try {
        const changelog = await fs.readFile(path.join(rootDir, 'CHANGELOG.md'), 'utf8');

        // Look for the current version header - also check for -temp suffix
        const tempVersion = `${version}-temp`;
        let versionHeaderRegex = new RegExp(`## \\[${version}\\] - \\d{4}-\\d{2}-\\d{2}`);
        let versionMatch = changelog.match(versionHeaderRegex);

        // If normal version isn't found, try the temp version
        if (!versionMatch) {
            versionHeaderRegex = new RegExp(`## \\[${tempVersion}\\] - \\d{4}-\\d{2}-\\d{2}`);
            versionMatch = changelog.match(versionHeaderRegex);
            if (!versionMatch) {
                throw new Error(`Could not find version ${version} or ${tempVersion} in the changelog`);
            }
        }

        const versionIndex = changelog.indexOf(versionMatch[0]);
        let endIndex;

        // Find the next version header or end of file
        const nextVersionMatch = changelog.slice(versionIndex + versionMatch[0].length).match(/\n## \[\d+\.\d+\.\d+/);
        if (nextVersionMatch) {
            endIndex = versionIndex + versionMatch[0].length + nextVersionMatch.index;
        } else {
            // If no next version found, include everything until <!-- generated by git-cliff -->
            const footerMatch = changelog.slice(versionIndex).match(/<!-- generated by git-cliff -->/);
            endIndex = footerMatch
                ? versionIndex + footerMatch.index
                : changelog.length;
        }

        // Extract the section for this version only
        const releaseNotes = "# Release Notes\n\n" +
            changelog.slice(versionIndex, endIndex).trim() +
            "\n";

        await fs.writeFile(path.join(rootDir, 'RELEASENOTES.md'), releaseNotes);
        console.log('✅ RELEASENOTES.md created successfully');

    } catch (error) {
        console.error('Error creating release notes:', error);
        throw error;
    }
}

// Function to fix the changelog by replacing temporary version with actual version
async function fixChangelog(tempVersion, actualVersion) {
    try {
        console.log(`\nFixing changelog: replacing ${tempVersion} with ${actualVersion}...`);
        const changelogPath = path.join(rootDir, 'CHANGELOG.md');
        let changelog = await fs.readFile(changelogPath, 'utf8');

        // Replace [version-temp] with [version]
        changelog = changelog.replace(`[${tempVersion}]`, `[${actualVersion}]`);

        await fs.writeFile(changelogPath, changelog);
        console.log('✅ Changelog fixed successfully');
    } catch (error) {
        console.error('Error fixing changelog:', error);
        throw error;
    }
}

// Function to clean up old build artifacts
async function cleanupBuildArtifacts() {
    console.log('\nCleaning up old build artifacts...');
    try {
        // Check if dist directory exists
        try {
            await fs.access(distDir);
        } catch (err) {
            console.log('No dist directory found, skipping cleanup.');
            return;
        }

        // Read current version
        const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf8'));
        const currentVersion = packageJson.version;

        // Get all files in dist directory
        const files = await fs.readdir(distDir);

        // Keep track of how many files were removed
        let removedCount = 0;

        // Process each file
        for (const file of files) {
            const filePath = path.join(distDir, file);

            // Skip directories and latest.yml/latest-linux.yml files
            const stat = await fs.stat(filePath);
            if (stat.isDirectory() ||
                file === 'latest.yml' ||
                file === 'latest-linux.yml' ||
                file === 'builder-debug.yml' ||
                file === 'builder-effective-config.yaml') {
                continue;
            }

            // Check if file is from a previous version
            // Look for version numbers in filenames like "Echo Location WX Setup 1.1.4.exe"
            // or "echo-location-wx_1.1.4_amd64.deb" or "Echo Location WX-1.1.4.AppImage"
            const versionRegex = /[._-](0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)/;
            const versionMatch = file.match(versionRegex);

            if (versionMatch) {
                const fileVersion = `${versionMatch[1]}.${versionMatch[2]}.${versionMatch[3]}`;

                // Remove file if it's an older version
                if (fileVersion !== currentVersion) {
                    console.log(`Removing old artifact: ${file}`);
                    await fs.unlink(filePath);
                    removedCount++;
                }
            }
        }

        console.log(`✅ Cleanup complete. Removed ${removedCount} old build artifacts.`);
    } catch (error) {
        console.error('Error cleaning up build artifacts:', error);
    }
}

async function release() {
    try {
        // Check for uncommitted changes
        try {
            execSync('git diff-index --quiet HEAD --', { stdio: 'ignore' });
        } catch (e) {
            console.error('❌ You have uncommitted changes. Please commit or stash them before releasing.');
            process.exit(1);
        }

        // Get current version
        const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf8'));
        const currentVersion = packageJson.version;
        console.log(`Current version: ${currentVersion}`);

        // Ask for release type
        const releaseType = await prompt('Release type (patch/minor/major): ');
        if (!['patch', 'minor', 'major'].includes(releaseType)) {
            console.error('❌ Invalid release type. Must be patch, minor, or major.');
            process.exit(1);
        }

        // Bump version based on release type
        console.log(`\nBumping ${releaseType} version...`);
        run(`node scripts/bump-version.js ${releaseType}`);

        // Read updated version
        const updatedPackageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf8'));
        const newVersion = updatedPackageJson.version;

        // Commit the version bump
        console.log('\nCommitting version bump...');
        run(`git add package.json`);
        run(`git commit -m "chore: bump version to ${newVersion}"`);

        // Create a temporary tag for the new version 
        // This allows git-cliff to find the new version
        console.log('\nCreating temporary tag for changelog generation...');
        const tempTagName = `v${newVersion}-temp`;
        run(`git tag -a ${tempTagName} -m "Temporary tag for v${newVersion}"`);

        // Now generate the changelog with the temporary tag in place
        console.log('\nUpdating changelog...');
        run('npm run changelog');

        // Fix the changelog to replace the temp version with the actual version
        await fixChangelog(`${newVersion}-temp`, newVersion);

        // Remove temporary tag after changelog is generated
        console.log('\nRemoving temporary tag...');
        run(`git tag -d ${tempTagName}`);

        // Create release notes specifically for this version
        await createReleaseNotes(newVersion);

        // Git operations
        console.log('\nCommitting changelog...');
        run(`git add CHANGELOG.md RELEASENOTES.md`);
        run(`git commit -m "chore: update changelog for v${newVersion}"`);

        console.log('\nCreating git tag...');
        run(`git tag -a v${newVersion} -m "Release v${newVersion}"`);

        // Build the application for all platforms
        console.log('\nBuilding application...');
        const buildTarget = await prompt('Build for which platforms? (all/win/linux): ');

        // Clean up old build artifacts before building
        await cleanupBuildArtifacts();

        switch (buildTarget.toLowerCase()) {
            case 'all':
                run('npm run build:all');
                break;
            case 'win':
                run('npm run build:win');
                break;
            case 'linux':
                run('npm run build:linux');
                break;
            default:
                console.log('Invalid option, building for all platforms');
                run('npm run build:all');
        }

        // Push changes and tags
        const shouldPush = await prompt('\nPush changes and tags to remote? (y/n): ');
        if (shouldPush.toLowerCase() === 'y') {
            console.log('\nPushing changes and tags...');
            run('git push');
            run('git push --tags');

            console.log(`\n✅ Release v${newVersion} completed successfully!`);
            console.log(`Build artifacts are available in the dist/ directory.`);
        } else {
            console.log(`\n✅ Release v${newVersion} completed locally.`);
            console.log('Remember to push your changes when ready:');
            console.log('  git push && git push --tags');
            console.log(`Build artifacts are available in the dist/ directory.`);
        }

    } catch (error) {
        console.error('Error during release process:', error);
        process.exit(1);
    } finally {
        rl.close();
    }
}

release();