// release.js
import { execSync } from 'child_process';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import readline from 'readline';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const rootDir = path.join(__dirname, '..');
const packageJsonPath = path.join(rootDir, 'package.json');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

// Helper function to prompt for input
const prompt = (question) => new Promise((resolve) => rl.question(question, resolve));

// Helper function to run a command and return stdout
const run = (cmd, options = {}) => {
    console.log(`> ${cmd}`);
    return execSync(cmd, { encoding: 'utf-8', stdio: 'inherit', ...options });
};

// Function to extract the latest version's changes from CHANGELOG.md
async function createReleaseNotes(version) {
    console.log('\nCreating release notes for the current version...');

    try {
        const changelog = await fs.readFile(path.join(rootDir, 'CHANGELOG.md'), 'utf8');

        // Look for the current version header
        const versionHeaderRegex = new RegExp(`## \\[${version}\\] - \\d{4}-\\d{2}-\\d{2}`);
        const versionMatch = changelog.match(versionHeaderRegex);

        if (!versionMatch) {
            throw new Error(`Could not find version ${version} in the changelog`);
        }

        const versionIndex = changelog.indexOf(versionMatch[0]);
        let endIndex;

        // Find the next version header or end of file
        const nextVersionMatch = changelog.slice(versionIndex + versionMatch[0].length).match(/\n## \[\d+\.\d+\.\d+\]/);
        if (nextVersionMatch) {
            endIndex = versionIndex + versionMatch[0].length + nextVersionMatch.index;
        } else {
            // If no next version found, include everything until <!-- generated by git-cliff -->
            const footerMatch = changelog.slice(versionIndex).match(/<!-- generated by git-cliff -->/);
            endIndex = footerMatch
                ? versionIndex + footerMatch.index
                : changelog.length;
        }

        // Extract the section for this version only
        const releaseNotes = "# Release Notes\n\n" +
            changelog.slice(versionIndex, endIndex).trim() +
            "\n";

        await fs.writeFile(path.join(rootDir, 'RELEASENOTES.md'), releaseNotes);
        console.log('✅ RELEASENOTES.md created successfully');

    } catch (error) {
        console.error('Error creating release notes:', error);
        throw error;
    }
}

async function release() {
    try {
        // Check for uncommitted changes
        try {
            execSync('git diff-index --quiet HEAD --', { stdio: 'ignore' });
        } catch (e) {
            console.error('❌ You have uncommitted changes. Please commit or stash them before releasing.');
            process.exit(1);
        }

        // Get current version
        const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf8'));
        const currentVersion = packageJson.version;
        console.log(`Current version: ${currentVersion}`);

        // Ask for release type
        const releaseType = await prompt('Release type (patch/minor/major): ');
        if (!['patch', 'minor', 'major'].includes(releaseType)) {
            console.error('❌ Invalid release type. Must be patch, minor, or major.');
            process.exit(1);
        }

        // Bump version based on release type
        console.log(`\nBumping ${releaseType} version...`);
        run(`node scripts/bump-version.js ${releaseType}`);

        // Read updated version
        const updatedPackageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf8'));
        const newVersion = updatedPackageJson.version;

        // Update changelog
        console.log('\nUpdating changelog...');
        run('npm run changelog');

        // Create release notes specifically for this version
        await createReleaseNotes(newVersion);

        // Git operations
        console.log('\nCommitting changes...');
        run(`git add package.json CHANGELOG.md RELEASENOTES.md`);
        run(`git commit -m "chore: release v${newVersion}"`);

        console.log('\nCreating git tag...');
        run(`git tag -a v${newVersion} -m "Release v${newVersion}"`);

        // Build the application for all platforms
        console.log('\nBuilding application...');
        const buildTarget = await prompt('Build for which platforms? (all/win/linux): ');

        switch (buildTarget.toLowerCase()) {
            case 'all':
                run('npm run build:all');
                break;
            case 'win':
                run('npm run build:win');
                break;
            case 'linux':
                run('npm run build:linux');
                break;
            default:
                console.log('Invalid option, building for all platforms');
                run('npm run build:all');
        }

        // Push changes and tags
        const shouldPush = await prompt('\nPush changes and tags to remote? (y/n): ');
        if (shouldPush.toLowerCase() === 'y') {
            console.log('\nPushing changes and tags...');
            run('git push');
            run('git push --tags');

            console.log(`\n✅ Release v${newVersion} completed successfully!`);
            console.log(`Build artifacts are available in the dist/ directory.`);
        } else {
            console.log(`\n✅ Release v${newVersion} completed locally.`);
            console.log('Remember to push your changes when ready:');
            console.log('  git push && git push --tags');
            console.log(`Build artifacts are available in the dist/ directory.`);
        }

    } catch (error) {
        console.error('Error during release process:', error);
        process.exit(1);
    } finally {
        rl.close();
    }
}

release();